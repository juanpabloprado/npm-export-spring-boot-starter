package org.mvnsearch.boot.npm.export.generator;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Schema;
import org.intellij.lang.annotations.Language;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.web.bind.annotation.*;

import java.lang.reflect.*;
import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Controller JavaScript Stub generator
 *
 * @author linux_china
 */
@SuppressWarnings("StringConcatenationInsideStringBufferAppend")
public class ControllerJavaScriptStubGenerator implements JavaToJsTypeConverter {
    private final Class<?> controllerClass;
    private final String jsClassName;
    private final List<Method> requestMethods;
    private final List<JsHttpStubMethod> jsHttpStubMethods;
    /**
     * javabean for typeDef from @Schema implementation
     */
    private final Map<Class<?>, String> javaBeanTypeDefMap = new HashMap<>();
    /**
     * customized typedef from @Schema properties
     */
    private Map<String, JSDocTypeDef> customizedTypeDefMap = new HashMap<>();
    private String basePath;

    public ControllerJavaScriptStubGenerator(Class<?> controllerClass) {
        this.controllerClass = controllerClass;
        RequestMapping requestMapping = AnnotationUtils.findAnnotation(controllerClass, RequestMapping.class);
        if (requestMapping != null) {
            String[] basePaths = requestMapping.value();
            if (basePaths.length > 0) {
                this.basePath = basePaths[0];
            }
        }
        this.requestMethods = Arrays.stream(this.controllerClass.getMethods())
                .filter(method -> AnnotationUtils.findAnnotation(method, RequestMapping.class) != null)
                .collect(Collectors.toList());
        this.jsHttpStubMethods = this.requestMethods.stream()
                .map(this::generateMethodStub)
                .collect(Collectors.toList());
        this.jsClassName = controllerClass.getSimpleName();
    }

    public String generate(String baseUrl) {
        @Language("JavaScript")
        String global = "// Don't edit this file because it was generated by Spring Boot App!!!\n" +
                "const axios = require('axios');\n" +
                "\n" +
                "let isBrowser = new Function('try {return this===window;}catch(e){ return false;}');\n" +
                "let isNode = new Function('try {return this===global;}catch(e){return false;}');\n" +
                "\n" +
                "axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n" +
                "\n" +
                "/**\n" +
                " * @param uri {string}\n" +
                " * @param pathVariables {object}\n" +
                " * @return {string}\n" +
                " */\n" +
                "function formatUri(uri, pathVariables) {\n" +
                "    let newUri = uri;\n" +
                "    for (const name in pathVariables) {\n" +
                "        newUri = newUri.replace('*{' + name + '}', pathVariables[name])\n" +
                "                .replace('{' + name + '}', pathVariables[name])\n" +
                "    }\n" +
                "    return newUri;\n" +
                "}\n\n";
        @Language(value = "JavaScript", suffix = "}")
        String classDeclare = "/**\n" +
                " " +
                "* @version $version\n" +
                " " +
                "*/\n" +
                "class XxxxController {\n" +
                "    constructor() {\n" +
                "        if (isBrowser()) {\n" +
                "            this.baseUrl = '';\n" +
                "        } else {\n" +
                "            this.baseUrl = 'http://localhost:8080'\n" +
                "        }\n" +
                "    }\n" +
                "\n" +
                "    /**\n" +
                "     * set base url\n" +
                "     * @param baseUrl base url\n" +
                "     * @returns {XxxxController}\n" +
                "     */\n" +
                "    setBaseUrl(baseUrl) {\n" +
                "        this.baseUrl = baseUrl;\n" +
                "        return this;\n" +
                "    }\n" +
                "\n" +
                "    /**\n" +
                "     * set JWT Token\n" +
                "     * @param token token token\n" +
                "     * @return {XxxxController}\n" +
                "     */\n" +
                "    setJwtToken(token) {\n" +
                "        this.jwtToken = token;\n" +
                "        return this;\n" +
                "    }\n" +
                "\n" +
                "    /**\n" +
                "     * set config filter\n" +
                "     * @param filter {function}\n" +
                "     * @return {XxxxController}\n" +
                "     */\n" +
                "    setConfigFilter(filter) {\n" +
                "        this.configFilter = filter;\n" +
                "        return this;\n" +
                "    }\n\n";
        StringBuilder builder = new StringBuilder();
        builder.append(global);
        String version = new SimpleDateFormat("yyyy.MM.dd").format(new Date());
        builder.append(classDeclare.replaceAll("XxxxController", jsClassName).replace("$version", version));
        for (JsHttpStubMethod jsHttpStubMethod : jsHttpStubMethods) {
            builder.append(toJsCode(jsHttpStubMethod, "    ") + "\n");
        }
        builder.append("}\n\n");
        builder.append("module.exports = new UserController();\n\n");
        builder.append(typedefs());
        return builder.toString();
    }

    public JsHttpStubMethod generateMethodStub(Method method) {
        JsHttpStubMethod stubMethod = new JsHttpStubMethod();
        stubMethod.setName(method.getName());
        //@deprecated
        Deprecated deprecated = method.getAnnotation(Deprecated.class);
        if (deprecated != null) {
            stubMethod.setDeprecated(true);
        }
        //@Operation from OpenAPI
        Operation operation = method.getAnnotation(Operation.class);
        if (operation != null) {
            stubMethod.setDescription(operation.description());
        }
        //@GetMapping, @PostMapping, @RequestMapping
        GetMapping getMapping = method.getAnnotation(GetMapping.class);
        PostMapping postMapping = method.getAnnotation(PostMapping.class);
        RequestMapping requestMapping = method.getAnnotation(RequestMapping.class);
        String[] paths = null;
        RequestMethod requestMethod = null;
        if (getMapping != null) {
            paths = getMapping.value();
            requestMethod = RequestMethod.GET;
        } else if (postMapping != null) {
            paths = postMapping.value();
            requestMethod = RequestMethod.POST;
        } else if (requestMapping != null) {
            paths = requestMapping.value();
            RequestMethod[] requestMethods = requestMapping.method();
            if (requestMethods.length > 0) {
                requestMethod = requestMethods[0];
            }
        }
        stubMethod.setMethod(requestMethod == null ? RequestMethod.POST : requestMethod);
        if (paths != null && paths.length > 0) {
            stubMethod.setPath(paths[0]);
        }
        if (basePath != null && !basePath.isEmpty()) {
            stubMethod.setPath(basePath + stubMethod.getPath());
        }
        //parameters
        Parameter[] parameters = method.getParameters();
        if (parameters.length > 0) {
            for (Parameter parameter : parameters) {
                JsParam jsParam = new JsParam();
                jsParam.setName(parameter.getName());
                jsParam.setType(parameter.getType());
                PathVariable pathVariable = parameter.getAnnotation(PathVariable.class);
                if (pathVariable != null) {
                    String value = pathVariable.value();
                    if (value.isEmpty()) {
                        value = jsParam.getName();
                    }
                    jsParam.setPathVariableName(value);
                    jsParam.setRequired(pathVariable.required());
                }
                RequestParam requestParam = parameter.getAnnotation(RequestParam.class);
                if (requestParam != null) {
                    String value = requestParam.value();
                    if (value.isEmpty()) {
                        value = parameter.getName();
                    }
                    jsParam.setDefaultValue(requestParam.defaultValue());
                    jsParam.setRequestParamName(value);
                    jsParam.setRequired(requestParam.required());
                }
                RequestHeader requestHeader = parameter.getAnnotation(RequestHeader.class);
                if (requestHeader != null) {
                    String value = requestHeader.value();
                    jsParam.setHttpHeaderName(value);
                    jsParam.setDefaultValue(requestHeader.defaultValue());
                    jsParam.setRequired(requestHeader.required());
                }
                RequestBody requestBody = parameter.getAnnotation(RequestBody.class);
                if (requestBody != null) {
                    jsParam.setBodyData(true);
                    Class<?> bodyType = parameter.getType();
                    if (bodyType.isAssignableFrom(String.class)) {
                        stubMethod.setRequestContentType("text/plain");
                    } else if (bodyType.isAssignableFrom(ByteBuffer.class)
                            || bodyType.isAssignableFrom(byte[].class)) {
                        stubMethod.setRequestContentType("application/octet-stream");
                    } else {
                        stubMethod.setRequestContentType("application/json");
                    }
                    jsParam.setRequired(requestBody.required());
                    //parameter schema
                    Schema schema = parameter.getAnnotation(Schema.class);
                    if (schema != null) {
                        //java class as response
                        if (schema.implementation() != Void.class) {
                            jsParam.setType(schema.implementation());
                        } else if (schema.requiredProperties().length > 0) {
                            JSDocTypeDef jsDocTypeDef = new JSDocTypeDef(schema.name());
                            for (String property : schema.requiredProperties()) {
                                jsDocTypeDef.addProperty(property);
                            }
                            jsParam.setJsDocTypeDef(jsDocTypeDef);
                        }
                    }
                }
                stubMethod.addParam(jsParam);
            }
        }
        //return type
        Type genericReturnType = method.getGenericReturnType();
        stubMethod.setReturnType(parseInferredClass(genericReturnType));
        //@Schema
        Schema schema = method.getAnnotation(Schema.class);
        if (schema != null) {
            //java class as response
            if (schema.implementation() != Void.class) {
                stubMethod.setReturnType(schema.implementation());
            } else if (schema.requiredProperties().length > 0) {
                JSDocTypeDef jsDocTypeDef = new JSDocTypeDef(schema.name());
                for (String property : schema.requiredProperties()) {
                    jsDocTypeDef.addProperty(property);
                }
                stubMethod.setJsDocTypeDef(jsDocTypeDef);
            }
        }
        return stubMethod;
    }

    public static Class<?> parseInferredClass(Type genericType) {
        Class<?> inferredClass = null;
        if (genericType instanceof ParameterizedType) {
            ParameterizedType type = (ParameterizedType) genericType;
            Type[] typeArguments = type.getActualTypeArguments();
            if (typeArguments.length > 0) {
                final Type typeArgument = typeArguments[0];
                if (typeArgument instanceof ParameterizedType) {
                    inferredClass = (Class<?>) ((ParameterizedType) typeArgument).getActualTypeArguments()[0];
                } else {
                    inferredClass = (Class<?>) typeArgument;
                }
            }
        }
        if (inferredClass == null && genericType instanceof Class) {
            inferredClass = (Class<?>) genericType;
        }
        return inferredClass;
    }

    public String toJsCode(JsHttpStubMethod stubMethod, String indent) {
        StringBuilder builder = new StringBuilder();
        builder.append(indent).append("/**\n");
        //description
        if (stubMethod.getDescription() != null && !stubMethod.getDescription().isEmpty()) {
            builder.append(indent).append("* " + stubMethod.getDescription() + "\n");
        } else {
            builder.append(indent).append("*\n");
        }
        //@deprecated
        if (stubMethod.isDeprecated()) {
            builder.append(indent).append("* @deprecated\n");
        }
        for (JsParam param : stubMethod.getParams()) {
            if (param.isFromRequestSide()) {
                if (param.isRequired()) {
                    builder.append(indent).append("* @param {" + param.getJsType() + "} " + param.getName() + "\n");
                } else {
                    //default value
                    if (param.getDefaultValue() != null && !param.getDefaultValue().isEmpty() && !param.getDefaultValue().equals(ValueConstants.DEFAULT_NONE)) {
                        builder.append(indent).append("* @param {" + param.getJsType() + "} [" + param.getName() + "=" + param.getDefaultValue() + "]\n");
                    } else {  //optional
                        builder.append(indent).append("* @param {" + param.getJsType() + "} [" + param.getName() + "]\n");
                    }
                }
                JSDocTypeDef jsDocTypeDef = param.getJsDocTypeDef();
                if (jsDocTypeDef != null) {
                    this.customizedTypeDefMap.put(jsDocTypeDef.getName(), jsDocTypeDef);
                }
            }
        }
        String jsReturnType = stubMethod.getJsReturnType();
        if (stubMethod.getJsDocTypeDef() == null && jsReturnType.contains("_")) {
            this.javaBeanTypeDefMap.put(stubMethod.getReturnType(), jsReturnType);
        }
        builder.append(indent).append("* @return {Promise<" + jsReturnType + ">}\n");
        builder.append(indent).append("*/\n");
        builder.append(indent).append(stubMethod.getName() + "(");
        if (!stubMethod.getParams().isEmpty()) {
            String paramsDeclare = stubMethod.getParams().stream()
                    .filter(JsParam::isFromRequestSide)
                    .map(JsParam::getName)
                    .collect(Collectors.joining(", "));
            builder.append(paramsDeclare);
        }
        builder.append(") {\n");
        builder.append(indent).append("  let config = {\n");
        if (stubMethod.hasPathVariable()) {
            builder.append(indent).append("    url: this.baseUrl + formatUri('" + stubMethod.getPath() + "'," + formatPathVariables(stubMethod) + "),\n");
        } else {
            builder.append(indent).append("    url: this.baseUrl + '" + stubMethod.getPath() + "',\n");
        }
        builder.append(indent).append("    headers: " + formatHttpHeaders(stubMethod) + ",\n");
        if (stubMethod.isPlainBody()) {
            builder.append(indent).append("     data: " + stubMethod.getRequestBodyParam().getName() + ",\n");
        } else {
            if (stubMethod.hasRequestParam()) {
                if (stubMethod.getMethod().equals(RequestMethod.GET)) {
                    builder.append(indent).append("    params: " + formatRequesterParams(stubMethod) + ",\n");
                } else {
                    builder.append(indent).append("    data: " + formatRequesterParams(stubMethod) + ",\n");
                }
            }
        }
        builder.append(indent).append("    method: '" + stubMethod.getMethod().name().toLowerCase() + "'\n");
        builder.append(indent).append("  };\n");
        builder.append(indent).append("  if (this.jwtToken != null) { config.headers['Authorization'] = 'Bearer ' + this.jwtToken; }\n");
        builder.append(indent).append("  if (this.configFilter != null) { config = this.configFilter(config); }\n");
        Class<?> returnType = stubMethod.getReturnType();
        if (returnType.isAssignableFrom(Integer.class) || returnType.isAssignableFrom(int.class)) {
            builder.append(indent).append("  return axios(config).then(response => {return parseInt(response.data);});\n");
        } else if (returnType.isAssignableFrom(Float.class)
                || returnType.isAssignableFrom(float.class)
                || returnType.isAssignableFrom(Double.class)
                || returnType.isAssignableFrom(double.class)) {
            builder.append(indent).append("  return axios(config).then(response => {return parseFloat(response.data);});\n");
        } else {
            builder.append(indent).append("  return axios(config).then(response => {return response.data;});\n");
        }
        builder.append(indent).append("}\n");
        return builder.toString();
    }

    public String formatPathVariables(JsHttpStubMethod stubMethod) {
        return "{" + stubMethod.getParams().stream()
                .filter(param -> param.getPathVariableName() != null)
                .map(param -> "\"" + param.getPathVariableName() + "\": " + param.getName())
                .collect(Collectors.joining(", ")) + "}";
    }

    public String formatHttpHeaders(JsHttpStubMethod stubMethod) {
        StringBuilder builder = new StringBuilder();
        builder.append("{");
        if (stubMethod.getRequestContentType() != null) {
            builder.append("\"Content-Type\": \"" + stubMethod.getRequestContentType() + "\"");
        }
        if (stubMethod.hasHttpHeader()) {
            builder.append(",").append(stubMethod.getParams().stream()
                    .filter(param -> param.getHttpHeaderName() != null)
                    .map(param -> "\"" + param.getHttpHeaderName() + "\": " + param.getName())
                    .collect(Collectors.joining(", ")));
        }
        builder.append("}");
        return builder.toString();
    }

    public String formatRequesterParams(JsHttpStubMethod stubMethod) {
        return "{" + stubMethod.getParams().stream()
                .filter(param -> param.getRequestParamName() != null)
                .map(param -> "\"" + param.getRequestParamName() + "\": " + param.getName())
                .collect(Collectors.joining(", ")) + "}";
    }

    public String typedefs() {
        StringBuilder builder = new StringBuilder();
        builder.append("//================ JSDoc typedef ========================//\n");
        for (Map.Entry<Class<?>, String> entry : javaBeanTypeDefMap.entrySet()) {
            Class<?> clazz = entry.getKey();
            builder.append("/**\n");
            builder.append("* @typedef {Object} " + entry.getValue() + "\n");
            for (Field field : clazz.getDeclaredFields()) {
                builder.append("* @property {" + toJsType(field.getType()) + "} " + field.getName() + "\n");
            }
            builder.append("*/\n");
        }
        //@typeDef for return type and parameter type
        Map<String, JSDocTypeDef> allTypeDefMap = new HashMap<>(this.customizedTypeDefMap);
        Map<String, JSDocTypeDef> typeDefForReturnTypeMap = jsHttpStubMethods.stream()
                .map(JsHttpStubMethod::getJsDocTypeDef)
                .filter(Objects::nonNull)
                .collect(Collectors.toMap(JSDocTypeDef::getName, jsDocTypeDef -> jsDocTypeDef, (a, b) -> b));
        allTypeDefMap.putAll(typeDefForReturnTypeMap);
        for (JSDocTypeDef jsDocTypeDef : allTypeDefMap.values()) {
            builder.append("/**\n");
            builder.append("* @typedef {Object} " + jsDocTypeDef.getName() + "\n");
            for (String property : jsDocTypeDef.getProperties()) {
                builder.append("* @property " + property + "\n");
            }
            builder.append("*/\n");
        }
        return builder.toString();
    }

}
